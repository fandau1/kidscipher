const fs = require("fs");
const path = require("path");
const { SVGIcons2SVGFontStream } = require("svgicons2svgfont");
const svg2ttf = require("svg2ttf");
const ttf2woff = require("ttf2woff");
const ttf2woff2 = require("ttf2woff2");


const INIT_GLYMP = 100; // <-- You can set starting Unicode here
const SVG_DIR = path.resolve(__dirname, "svg");
const OUTPUT_DIR = path.resolve(__dirname, "output");
const JS_TYPE_FILENAME = "KidscipherGlyphs.js";
const JS_TYPE_FILE = path.join(OUTPUT_DIR, JS_TYPE_FILENAME);
const FONT_NAME = "Kidscipher";

// Ensure output folder exists
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR, { recursive: true });

// Recursively get all SVG files
function getAllSVGFiles(dir) {
  let files = [];
  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);
    if (stat.isDirectory()) {
      files = files.concat(getAllSVGFiles(fullPath));
    } else if (file.endsWith(".svg")) {
      files.push(fullPath);
    }
  });
  return files;
}

const svgFiles = getAllSVGFiles(SVG_DIR);

// Prepare JS enum lines
const lines = [`// Auto-generated by generate-font`, `const ${FONT_NAME}Glyphs = Object.freeze({`];

// Create SVG font stream
const fontStream = new SVGIcons2SVGFontStream({ fontName: FONT_NAME, normalize: true });
const svgFontPath = path.join(OUTPUT_DIR, `${FONT_NAME}.svg`);
const writeStream = fs.createWriteStream(svgFontPath);
fontStream.pipe(writeStream);

let currentCode = INIT_GLYMP;

svgFiles.forEach((file) => {
  console.log(`Processing ${file}`);
  const glyphStream = fs.createReadStream(file);
  const filename = path.basename(file, ".svg").toUpperCase().replace(/\W+/g, "_");
  const unicodeChar = String.fromCharCode(currentCode);

  glyphStream.metadata = { unicode: [unicodeChar], name: filename };
  fontStream.write(glyphStream);

  lines.push(`  ${filename}: "\\u{${currentCode.toString(16)}}",`);
  currentCode++;
});

fontStream.end();

// Wait until SVG font is fully written
writeStream.on("finish", () => {
  console.log("SVG font created:", svgFontPath);

  // Read SVG font and convert to TTF
  const svgFont = fs.readFileSync(svgFontPath, "utf-8");
  const ttfBuffer = Buffer.from(svg2ttf(svgFont, {}).buffer);
  const ttfPath = path.join(OUTPUT_DIR, `${FONT_NAME}.ttf`);
  fs.writeFileSync(ttfPath, ttfBuffer);
  console.log("TTF font created:", ttfPath);

  // Convert to WOFF / WOFF2
  fs.writeFileSync(path.join(OUTPUT_DIR, `${FONT_NAME}.woff`), Buffer.from(ttf2woff(ttfBuffer).buffer));
  console.log("WOFF font created.");

  // Write JS enum-like file
  lines.push("});");
  lines.push(`module.exports = { ${FONT_NAME}Glyphs };`)
  fs.writeFileSync(JS_TYPE_FILE, lines.join("\n"));
  console.log("JS Glyphs file generated:", JS_TYPE_FILE);

  const DEST_FONTS_DIR = path.resolve(__dirname, "../../src/fonts");

  // Ensure the destination folder exists
  if (!fs.existsSync(DEST_FONTS_DIR)) fs.mkdirSync(DEST_FONTS_DIR, { recursive: true });

  // Paths of generated files
  const filesToCopy = [
    path.join(OUTPUT_DIR, `${FONT_NAME}.ttf`),
    path.join(OUTPUT_DIR, `${FONT_NAME}.woff`),
    JS_TYPE_FILE
  ];

  // Copy files to src/fonts
  filesToCopy.forEach((filePath) => {
    const destPath = path.join(DEST_FONTS_DIR, path.basename(filePath));
    fs.copyFileSync(filePath, destPath);
    console.log(`Copied ${filePath} -> ${destPath}`);
  });
});


